
%----------------------------------------------------------------------------
\chapter{Preliminaries}
%----------------------------------------------------------------------------



\section{Modeling using graphs}

Structural and behavioral modeling of systems are often done using graphs. Graphs are useful abstraction as they are easy to understand, intuitive to use, and lots of existing algorithms can be used to process them. 

To extend its usability, graphs can be extended by:
\begin{itemize}
	\item Attributes can be added to nodes
	\item Edges can 
\end{itemize}

This models structure can also be restricted by defining a metamodel

\section{Runtime modeling}

In this framework, we use structural modeling to model the current state of the system. This model is called the live model, which captures the state and the operating context of the system. We monitor the system through this model: The model is updated with sensor data and information from other sources, so the model represents the physical system's latest state. 

\section{Graph pattern matching concepts}

A graph pattern's purpose is to define a list of variables, representing nodes, and a set of constraints for those variables. Some of the possible constraints are:

\begin{itemize}
	\item Type constraint -- a given node must be an instance of a type
	\item Reference -- a given reference must exist between two node
	\item Equality -- two variable must be the same
	\item Pattern match -- a subset of variables match to another graph pattern
	\item Negative application condition (NAC) -- a subset of variables must not match to another graph pattern
\end{itemize}
A list of vertices is called a \emph{match}, if binding them to the variables causes the constraints to be true.


\begin{figure}[h]
	\begin{center}
		\includegraphics[width=0.75\textwidth]{figures/pattern-visual.pdf}
		\caption{Non-formal visual representation of a graph pattern}
		\label{pattern-visual}
	\end{center}
\end{figure}


\section{Local search}

Local search~\cite{bur-marton-msc} is an algorithm to provide matchings of a graph pattern in a graph. It is a depth-first search in the space of variable bindings. In the root of the search tree all the variables are unbound. Then with each constraint, we add a new level for the tree. The child of a variable binding is all the other variable binding where 
\begin{itemize}
	\item The bound variables of the parent are bound to the same values as the corresponding variable in the child
	\item The constraint is satisfied by the child
\end{itemize}

The search tree can be traversed without materializing it with depth-first search. This means, that the elements of the search tree are calculated on the fly, by modifying the parent variable binding.

To optimize the size of the search tree the order of the constraints must be chosen properly. 

\section{Distributed platform}

% adatok diszjunkt halmazokra bontva különböző csomópontra
% az algoritmusok is elosztottak, nem lesz összegyűjtve az infó, úgy van kiértékelve, hogy nincs aki mindent látna a rendszerből

As cyber-physical systems are distributed we must deal with the sensor data coming from different sensors at different computation units of the system. Sending the sensor data to one computation unit and evaluate on that cause different problems: Sensor data can be huge to send it through the network, the central node can be a SPOF, etc. In the presented framework the live model is distributed on the different computation units and the graph pattern matching algorithm itself runs in a distributed way. This eliminates the problem of central computers, but introduces complexity, that we must handle. 









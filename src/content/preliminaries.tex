
%----------------------------------------------------------------------------
\chapter{Preliminaries}
%----------------------------------------------------------------------------


\section{Modeling using graphs}

Structural and behavioral modeling of systems are often done using graphs. 
Graphs are useful abstraction as they are easy to understand, intuitive to use, and lots of existing algorithms can be used to process them. 
As model based approach uses models mostly of graph based formalism, in this section, graph based modeling is presented.

A directed graph consists of a set of nodes and a set of edges, where edges are a tuple of two node: a source-- and target node of that edge. 
Graphs can be extended to make them suitable for modeling:

\begin{itemize}
	\item by nodes having attributes with given values (e.g.\ name)
	\item by edges having labels implying their semantics
\end{itemize}

With this extended graph model, there is also a need to give rules for certain types of models, which is the main purpose of domain modeling.
A \emph{domain model} is a metamodel, defining the restrictions for the graph model of a system, i.e.\ what types of nodes exist, what kind of edges can go from one node to another, or what kind of attributes a node can have.

\begin{figure}[h]
	\begin{center}
		\includegraphics[width=0.75\textwidth]{figures/graphs.pdf}
		\caption{Basic graph (left), and extended (right) }
		\label{fig:graphs}
	\end{center}
\end{figure}


\section{Domain and runtime modeling}

In this framework, we use structural modeling to model the current state of the system. 
The state and the operating context of the system is captured in a model called the \emph{live model}.
It is updated with sensor data and information from other sources, so the model represents the physical system's latest state. 
This model can be used to infer problems in the state of the system, so it can be used for runtime verification.



\begin{figure}[h]
	\begin{center}
		\includegraphics[width=0.75\textwidth]{figures/live-models.pdf}
		\caption{Live model updating}
		\label{fig:live-models}
	\end{center}
\end{figure}

\section{Graph pattern matching concepts}

As runtime analysis of the system is based on the runtime model, we needs to identify problems in the graph model. 
Graph pattern matching offers a solution for this task. 
The goal of graph pattern matching is to find all the subgraphs of a graph meeting a certain criteria, defined by a \emph{graph pattern}.

A \emph{graph pattern} is given by a \emph{restricted} first-order logical expression, where variables refer to vertices of the graph.
Not quantified variables are called \emph{parameters}.  
A \emph{pattern match} is a variable binding between parameters and graph vertices, that satisfies the expression.
A \emph{graph query} is a program or execution plan capable of calculating the matches of a graph pattern on a given graph. 
Planning the most efficient graph query is crucial, because the performance of the verification depends on it.

Graph patterns are built up from basic constraints. 
A constraint is a predicate on a tuple of variables. 
These constraints are: 

\begin{itemize}
	\item Type constraint -- Satisfied, when the variable's value is a vertex of a given type
	\item Reference -- Satisfied, when an edge with a given label exists from the first variables value to the second variables value
	\item Equality -- two variable's value is the same
	\item Inequality -- two variable's values are different
	\item Pattern match -- a tuple of variable values are a match of another pattern
	\item Negative application condition (NAC) -- a tuple of variable values are \emph{not} a match of another pattern
\end{itemize}


We built up the expression defining the graph pattern the following way. 
An expression is a logical conjunction of subexpressions called pattern bodies ($Pattern = B_1 \wedge B_2 \wedge \dots$). 
A \emph{pattern body} existentially quantifyes all the variables \todo{ITT KELL EZT KICSIT OKOSABBAN: Kvantifikált változók majd kényszerek diszjunkciója}


We can also use a visual representation (see Fig. \ref{fig:pattern-visual}) to illustrate a graph pattern, altough textural languages (see VQL) is used in the framework.

\begin{figure}[h]
	\begin{center}
		\includegraphics[width=0.75\textwidth]{figures/pattern-visual.pdf}
		\caption{Non-formal visual representation of a graph pattern}
		\label{fig:pattern-visual}
	\end{center}
\end{figure}


\section{Local search}

Local search~\cite{bur-marton-msc} is a method for solving problems where the task is to find solutions involving a search space., which provides matchings of a graph pattern in a graph. It is a depth-first search in the space of variable bindings. In the root of the search tree all the variables are unbound. Then with each constraint, we add a new level for the tree. The child of a variable binding is all the other variable binding where 
\begin{itemize}
	\item The bound variables of the parent are bound to the same values as the corresponding variable in the child
	\item The constraint is satisfied by the child
\end{itemize}

The search tree can be traversed without materializing it with depth-first search. This means, that the elements of the search tree are calculated on the fly, by modifying the parent variable binding.

To optimize the size of the search tree the order of the constraints must be chosen properly. 

\section{Distributed platform}

% adatok diszjunkt halmazokra bontva különböző csomópontra
% az algoritmusok is elosztottak, nem lesz összegyűjtve az infó, úgy van kiértékelve, hogy nincs aki mindent látna a rendszerből

As cyber-physical systems are distributed we must deal with the sensor data coming from different sensors at different computation units of the system. 
Sending the sensor data to one computation unit and evaluate on that cause different problems: 
Sensor data can be huge to send it through the network, the central node can be a SPOF, etc. 
In the presented framework the live model is distributed on the different computation units and the graph pattern matching algorithm itself runs in a distributed way. 
This eliminates the problem of central computers, but introduces complexity, that we must handle.

\subsection{Distributed graph modeling}

In this thesis, the phrase \emph{computing module} is used to denote a physical or virtual execution component of the cps that is capable of storing a part of the graph model and updates it to fit the current state the physical world, eg.\ an embedded system or a virtual machine.

Distributed graph models can be architected in various ways. 
In our framework each node in the graph are allocated to a computing element. 
On that computing element, call that node a \emph{local node}. 
In the context of other computing modules this node is a \emph{remote node}. 
Edges are stored in the computing module of their source node; 
If their destination node is not a local node on that node, a \emph{proxy node} is used to substitute the remote node.

\subsection{Distributed query execution}

Distributed query execution is used in the framework to provide matches to graph patterns. 
A distributed local search planner shall consider distributed execution to improve its execution performance.







